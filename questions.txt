# Questions and Unclear Design Decisions

## 1. XLangAST vs XLangNode
**Question**: What is the difference between XLangAST and XLangNode?
**Status**: Currently using XLangNode everywhere. XLangAST type is not defined in xlangtypes.nim.
**Decision needed**:
- Should XLangAST be a seq[XLangNode]?
- Or should it be a wrapper type with metadata?
- For now, using XLangNode as the root type.

## 2. JSON Structure from Parsers
**Question**: What is the exact JSON structure that the Go/Python/C#/Java parsers produce?
**Status**: The jsony example shows a structure with "declarations", "statements", "callee", "arguments" fields,
but XLangNode uses different field names (e.g., "children", "blockBody", "callFunc", "callArgs").
**DECISION**: ✅ **jsontoxlangtypes.nim should do field name translation**
- Parsers can output their natural field names
- jsontoxlangtypes.nim will translate to XLangNode field names
- This decouples parser implementation from XLang AST structure

## 3. Transformation Pass Order
**Question**: Does the order of transformation passes matter?
**Status**: Currently all lowering passes are registered in arbitrary order.
**DECISION**: ✅ **Make passes explicitly declare dependencies**
- Each pass has an enum identifier
- Each pass object lists dependency passes that should run before it
- Run lowest (leaf node in dependency tree) pass repeatedly until that construct disappears
- Then run next level passes, etc.
- Need simple hashtable method to detect circular dependencies
- Learn actual dependencies from usage/experience or research other transpilers

## 4. Nested Transformations
**Question**: How should passes handle deeply nested constructs?
**Status**: Pass manager recursively applies passes to children, but individual passes also recurse.
**Potential issue**: Double recursion might cause inefficiency or unexpected behavior.
**Decision needed**:
- Should individual transformation functions be responsible for recursion?
- Or should pass manager handle all recursion?
- **Current approach**: Both. Pass manager recurses through AST structure, individual passes handle their own node transformations.

## 5. Module Structure (src/ vs root)
**Question**: Should all .nim files be in src/, or keep some at root?
**Status**: Currently:
- New code in src/transforms/ and src/
- Old code at root (xlangtypes.nim, xlangtonim_complete.nim, etc.)
**DECISION**: ✅ **Current structure is good**
- Keep transforms separate in src/ - this is better
- Core types can stay at root
- No need to reorganize

## 6. Error Handling
**Question**: How should transformation errors be handled?
**Status**: No error handling currently implemented.
**DECISION**: ✅ **Transformation errors are critical failure**
- Report all errors we can detect
- Then exit with failure status
- Don't try to continue with malformed AST
- Collect multiple errors where possible before exiting
- Clear error messages indicating what went wrong and where

## 7. Testing Strategy
**Question**: What level of testing is needed?
**Status**: Have round-trip tests (Nim→XLang→Nim) and basic transformation tests.
**DECISION**: ✅ **Two complementary approaches**
1. **Integration tests with real code** - Test with actual programs
2. **Unit tests per construct** - Like Mono compiler's extensive C# tests
   - Test each language construct individually
   - Ensures comprehensive coverage
   - Easier to debug when something breaks

## 8. Language Parser Integration
**Question**: How should native language parsers be invoked?
**Status**: Parsers exist in parsers/ directory but not integrated into main.nim yet.
**DECISION**: ✅ **Language parsers are separate programs**
- Each parser is a standalone executable
- Parser reads source code, outputs JSON
- JSON-to-XLang conversion also separate programs for each language
- Clean separation of concerns
- Can be developed/tested independently

## 9. Nim Code Formatting
**Question**: Should generated Nim code be formatted?
**Status**: Currently just using repr() which can produce ugly code.
**DECISION**: ✅ **Don't care, nimpretty is enough**
- Very low priority
- Users can run nimpretty on generated code if needed
- Focus on correctness, not prettiness

## 10. Optimization Passes
**Question**: Should we implement optimization passes, or just lowering?
**Status**: Only lowering passes implemented so far.
**DECISION**: ✅ **No optimizations except making code idiomatic**
- Prefer concise high-level constructs over equivalent low-level ones
- Don't do performance optimizations (constant folding, dead code elimination, etc.)
- Focus on readability and idiomaticity
- Let Nim compiler handle performance optimizations

## 11. Pragmas and Attributes
**Question**: How should we handle language-specific pragmas/attributes?
**Status**: XLangNode has pragmas field, but transformation passes don't use it yet.
**DECISION**: ✅ **This is tough - mostly ignore, let user port manually**
- Only translate if we know exactly how macros/attributes expand
- Or if input language compiler has built-in ability to expand them to code
- Otherwise: ignore and let user handle manually
- Too complex to handle generally without semantic understanding
- Examples that could work:
  - Python @property → Nim property pattern (we know the semantics)
  - Simple annotations with clear meaning
- Examples to skip:
  - Complex macros with arbitrary expansion
  - Framework-specific attributes (e.g., ASP.NET, Django)

## 12. Generic Type Parameters
**Question**: How should complex generic constraints be handled?
**Status**: Basic generic types work, but complex constraints might not translate well.
**DECISION**: ✅ **Translate directly, sometimes add concept (interface)**
- Direct translation for simple cases
- Add Nim concept when input has interface constraint
- Examples:
  - Go `comparable` → Nim concept with `==` operator
  - C# `where T : IComparable<T>` → Nim concept
  - Simple type parameters translate directly

## 13. Async/Await Semantics
**Question**: How should async/await be translated between languages?
**Status**: All languages handle async differently.
**DECISION**: ✅ **Context-dependent approach**
- **Where semantics are similar**: Translate directly
  - Python async/await → Nim async/await
  - C# Task → Nim Future[T]
- **Where paradigms differ** (goroutines, Erlang mailboxes):
  - Include support for std lib or third-party libs with direct mapping
  - Use libraries that provide same DSL/abstraction
  - May need helper library to bridge paradigms

## 14. Memory Management
**Question**: How to handle GC vs manual memory?
**Status**: Nim has both GC and manual memory options.
**DECISION**: ✅ **Won't do low-level input languages**
- Only support high-level languages (Python, Go, C#, Java, etc.)
- All have GC, so translation is straightforward
- No need to handle manual memory management (C++, Rust)
- Keeps scope manageable
- Focus on high-level to high-level transpilation

## 15. Import/Module System
**Question**: How should imports be translated?
**Status**: xnkImport exists but no transformation logic.
**DECISION**: ✅ **Nim has flexible import, but special handling for some languages**
- **General**: Nim's import system is flexible enough for most cases
- **C# special case**:
  - Namespace is a DLL, not a single file
  - Aggregate all code together
  - Roslyn can handle DLL or namespace as the code unit
  - May need to bundle multiple files into single Nim module
- **Other languages**: Direct mapping usually works
  - Python modules → Nim modules
  - Go packages → Nim modules

---

## Implementation Priority (Updated with Decisions)

**Immediate Priority** (architectural improvements):
1. ✅ #3 - **Pass dependency system** - Implement enum-based dependency tracking
2. ✅ #6 - **Error handling** - Add critical failure handling with error collection
3. #2 - **JSON field translation** - Update jsontoxlangtypes.nim

**High Priority** (needed for basic functionality):
4. #7 - **Testing** - Unit tests per construct + integration tests
5. #8 - **Parser integration** - Shell out to parser executables

**Medium Priority** (improves capabilities):
6. #15 - **Import translation** - Handle C# namespaces, general imports
7. #12 - **Generic constraints** - Add concept generation for constraints
8. #13 - **Async translation** - Handle different async paradigms

**Low Priority** (defer):
9. #11 - **Pragmas/attributes** - Only simple cases
10. #9 - **Code formatting** - Users can run nimpretty
11. #10 - **Optimizations** - Out of scope except idiomaticity
12. #14 - **Memory management** - Out of scope (high-level langs only)

**Note**: Many questions now have clear decisions, reducing uncertainty significantly!
