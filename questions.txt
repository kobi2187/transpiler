# Questions and Unclear Design Decisions

## 1. XLangAST vs XLangNode
**Question**: What is the difference between XLangAST and XLangNode?
**Status**: Currently using XLangNode everywhere. XLangAST type is not defined in xlangtypes.nim.
**Decision needed**:
- Should XLangAST be a seq[XLangNode]?
- Or should it be a wrapper type with metadata?
- For now, using XLangNode as the root type.

## 2. JSON Structure from Parsers
**Question**: What is the exact JSON structure that the Go/Python/C#/Java parsers produce?
**Status**: The jsony example shows a structure with "declarations", "statements", "callee", "arguments" fields,
but XLangNode uses different field names (e.g., "children", "blockBody", "callFunc", "callArgs").
**Decision needed**:
- Should parsers output JSON matching XLangNode field names exactly?
- Or should jsontoxlangtypes.nim do field name translation?
- **Current approach**: Assume parsers output JSON matching XLangNode field names exactly.

## 3. Transformation Pass Order
**Question**: Does the order of transformation passes matter?
**Status**: Currently all lowering passes are registered in arbitrary order.
**Considerations**:
- Some transformations might depend on others being done first
- Example: Should ternary-to-if run before or after for-to-while?
**Decision needed**:
- Establish a canonical pass order
- Or make passes explicitly declare dependencies
- **Current approach**: Run all passes iteratively until no changes occur (up to maxIterations)

## 4. Nested Transformations
**Question**: How should passes handle deeply nested constructs?
**Status**: Pass manager recursively applies passes to children, but individual passes also recurse.
**Potential issue**: Double recursion might cause inefficiency or unexpected behavior.
**Decision needed**:
- Should individual transformation functions be responsible for recursion?
- Or should pass manager handle all recursion?
- **Current approach**: Both. Pass manager recurses through AST structure, individual passes handle their own node transformations.

## 5. Module Structure (src/ vs root)
**Question**: Should all .nim files be in src/, or keep some at root?
**Status**: Currently:
- New code in src/transforms/ and src/
- Old code at root (xlangtypes.nim, xlangtonim_complete.nim, etc.)
**Decision needed**:
- Move everything to src/?
- Keep dual structure?
- **Current approach**: New transformation code in src/, core AST types at root.

## 6. Error Handling
**Question**: How should transformation errors be handled?
**Status**: No error handling currently implemented.
**Scenarios**:
- Invalid JSON from parser
- Malformed XLang AST
- Transformation pass fails
- Nim code generation fails
**Decision needed**:
- Use exceptions?
- Use Result[T, E] pattern?
- Just let it crash?
- **Current approach**: No explicit error handling yet.

## 7. Testing Strategy
**Question**: What level of testing is needed?
**Status**: Have round-trip tests (Nim→XLang→Nim) and basic transformation tests.
**Missing**:
- End-to-end tests (JSON→XLang→Transform→Nim)
- Tests for each language parser
- Integration tests with real code
**Decision needed**: Prioritize which tests to implement first.

## 8. Language Parser Integration
**Question**: How should native language parsers be invoked?
**Status**: Parsers exist in parsers/ directory but not integrated into main.nim yet.
**Options**:
- Shell out to run parser executables
- Compile parsers as libraries and use FFI
- Use language-specific tooling
**Decision needed**: Choose integration approach for each language.

## 9. Nim Code Formatting
**Question**: Should generated Nim code be formatted?
**Status**: Currently just using repr() which can produce ugly code.
**Options**:
- Implement custom pretty printer
- Use nimpretty tool
- Accept ugly but functional code
**Decision needed**: Is pretty output a priority?

## 10. Optimization Passes
**Question**: Should we implement optimization passes, or just lowering?
**Status**: Only lowering passes implemented so far.
**Examples of optimizations**:
- Constant folding
- Dead code elimination
- Loop unrolling
**Decision needed**: Is optimization in scope for this project?

## 11. Pragmas and Attributes
**Question**: How should we handle language-specific pragmas/attributes?
**Status**: XLangNode has pragmas field, but transformation passes don't use it yet.
**Examples**:
- Python decorators → Nim pragmas
- C# attributes → Nim pragmas
- Go build tags → ???
**Decision needed**: Define mapping strategy for each language's metadata.

## 12. Generic Type Parameters
**Question**: How should complex generic constraints be handled?
**Status**: Basic generic types work, but complex constraints might not translate well.
**Examples**:
- Go: func Foo[T comparable](x T)
- C#: where T : IComparable<T>
- Nim: proc foo[T: SomeNumber](x: T)
**Decision needed**: Define translation rules for generic constraints.

## 13. Async/Await Semantics
**Question**: How should async/await be translated between languages?
**Status**: All languages handle async differently.
**Challenges**:
- Python: async/await with event loop
- C#: Task-based async
- Go: goroutines and channels (no async/await)
- Nim: async/await with Future[T]
**Decision needed**: Define async translation strategy for each language pair.

## 14. Memory Management
**Question**: How to handle GC vs manual memory?
**Status**: Nim has both GC and manual memory options.
**Challenges**:
- Go (GC) → Nim (GC) ✓ easy
- C# (GC) → Nim (GC) ✓ easy
- C++ (manual) → Nim (???)
- Rust (ownership) → Nim (???)
**Decision needed**: Define memory management translation strategy.

## 15. Import/Module System
**Question**: How should imports be translated?
**Status**: xnkImport exists but no transformation logic.
**Challenges**:
- Python: import foo, from foo import bar
- Go: import "path/to/package"
- C#: using Namespace;
- Nim: import module, from module import symbol
**Decision needed**: Define import translation rules.

---

## Recommendations for Priority

**High Priority** (needed for basic functionality):
1. #2 - JSON structure standardization
2. #6 - Basic error handling
3. #7 - End-to-end integration tests
4. #8 - Parser integration

**Medium Priority** (improves usability):
5. #1 - XLangAST type definition
6. #3 - Pass ordering strategy
7. #15 - Import translation

**Low Priority** (can defer):
8. #5 - Directory restructuring
9. #9 - Code formatting
10. #10 - Optimization passes
11. #11-14 - Advanced language features
