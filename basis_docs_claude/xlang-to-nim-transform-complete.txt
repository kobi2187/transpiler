import macros
import options

type
  XLangNodeKind = enum
    # ... (as defined in our XLang AST)

  XLangNode = ref object
    # ... (as defined in our XLang AST)

proc transformToNim(node: XLangNode): NimNode =
  case node.kind
  of xnkFile:
    result = newStmtList()
    for decl in node.moduleDecls:
      result.add(transformToNim(decl))

  of xnkModule:
    result = newStmtList()
    for stmt in node.moduleBody:
      result.add(transformToNim(stmt))

  of xnkNamespace:
    # Nim doesn't have direct namespace equivalent, we'll use modules
    result = newStmtList()
    for stmt in node.namespaceBody:
      result.add(transformToNim(stmt))

  of xnkFuncDecl, xnkMethodDecl:
    let params = newNimNode(nnkFormalParams)
    if node.returnType.isSome:
      params.add(transformToNim(node.returnType.get))
    else:
      params.add(newEmptyNode())
    for param in node.params:
      params.add(transformToNim(param))

    result = newProc(
      name = newIdentNode(node.funcName),
      params = params,
      body = transformToNim(node.body),
      procType = nnkProcDef
    )
    if node.isAsync:
      result.addPragma(newIdentNode("async"))

  of xnkClassDecl, xnkStructDecl:
    result = newNimNode(nnkTypeSection)
    let objType = newNimNode(nnkObjectTy)
    objType.add(newEmptyNode())
    
    let inheritanceList = newNimNode(nnkOfInherit)
    for baseType in node.baseTypes:
      inheritanceList.add(transformToNim(baseType))
    objType.add(inheritanceList)

    let recList = newNimNode(nnkRecList)
    for member in node.members:
      recList.add(transformToNim(member))
    objType.add(recList)

    result.add(
      newNimNode(nnkTypeDef).add(
        newIdentNode(node.typeName),
        newEmptyNode(),
        newNimNode(nnkRefTy).add(objType)
      )
    )

  of xnkInterfaceDecl:
    # Nim doesn't have direct interface equivalent, we'll use concepts
    result = newNimNode(nnkTypeSection)
    let conceptDef = newNimNode(nnkTypeDef)
    conceptDef.add(newIdentNode(node.typeName))
    conceptDef.add(newEmptyNode())
    let conceptTy = newNimNode(nnkConceptTy)
    for method in node.members:
      conceptTy.add(transformToNim(method))
    conceptDef.add(conceptTy)
    result.add(conceptDef)

  of xnkEnumDecl:
    result = newNimNode(nnkTypeSection)
    let enumTy = newNimNode(nnkEnumTy)
    enumTy.add(newEmptyNode())
    for member in node.enumMembers:
      if member.value.isSome:
        enumTy.add(newNimNode(nnkEnumFieldDef).add(
          newIdentNode(member.name),
          transformToNim(member.value.get)
        ))
      else:
        enumTy.add(newIdentNode(member.name))
    result.add(
      newNimNode(nnkTypeDef).add(
        newIdentNode(node.enumName),
        newEmptyNode(),
        enumTy
      )
    )

  of xnkVarDecl, xnkConstDecl:
    result = newNimNode(if node.kind == xnkVarDecl: nnkVarSection else: nnkConstSection)
    let identDefs = newNimNode(nnkIdentDefs)
    identDefs.add(newIdentNode(node.declName))
    if node.declType.isSome:
      identDefs.add(transformToNim(node.declType.get))
    else:
      identDefs.add(newEmptyNode())
    if node.initializer.isSome:
      identDefs.add(transformToNim(node.initializer.get))
    else:
      identDefs.add(newEmptyNode())
    result.add(identDefs)

  of xnkTypeDecl:
    result = newNimNode(nnkTypeSection)
    result.add(
      newNimNode(nnkTypeDef).add(
        newIdentNode(node.typeDefName),
        newEmptyNode(),
        transformToNim(node.typeDefBody)
      )
    )

  of xnkPropertyDecl:
    # Nim doesn't have built-in properties, we'll use procedures
    result = newStmtList()
    let getterProc = newProc(
      name = newIdentNode(node.propName),
      params = [transformToNim(node.propType)],
      body = transformToNim(node.getter.get),
      procType = nnkProcDef
    )
    result.add(getterProc)
    if node.setter.isSome:
      let setterProc = newProc(
        name = newIdentNode(node.propName & "="),
        params = [
          newEmptyNode(),
          newIdentDefs(newIdentNode("value"), transformToNim(node.propType))
        ],
        body = transformToNim(node.setter.get),
        procType = nnkProcDef
      )
      result.add(setterProc)

  of xnkFieldDecl:
    result = newIdentDefs(
      newIdentNode(node.fieldName),
      transformToNim(node.fieldType)
    )
    if node.fieldInitializer.isSome:
      result.add(transformToNim(node.fieldInitializer.get))
    else:
      result.add(newEmptyNode())

  of xnkConstructorDecl:
    result = newProc(
      name = newIdentNode("new"),
      params = [
        newIdentNode("self"),
        transformToNim(node.constructorParams)
      ],
      body = newStmtList(
        transformToNim(node.constructorInitializers),
        transformToNim(node.constructorBody)
      ),
      procType = nnkProcDef
    )

  of xnkDestructorDecl:
    # Nim uses destructors with `=destroy`
    result = newProc(
      name = newIdentNode("=destroy"),
      params = [
        newEmptyNode(),
        newIdentDefs(newIdentNode("self"), newIdentNode("typedesc"))
      ],
      body = transformToNim(node.destructorBody),
      procType = nnkProcDef
    )

  of xnkDelegateDecl:
    # Nim doesn't have delegates, we'll use function types
    result = newNimNode(nnkTypeSection)
    let funcTy = newNimNode(nnkProcTy)
    let formalParams = newNimNode(nnkFormalParams)
    if node.delegateReturnType.isSome:
      formalParams.add(transformToNim(node.delegateReturnType.get))
    else:
      formalParams.add(newEmptyNode())
    for param in node.delegateParams:
      formalParams.add(transformToNim(param))
    funcTy.add(formalParams)
    funcTy.add(newEmptyNode())  # pragmas
    result.add(
      newNimNode(nnkTypeDef).add(
        newIdentNode(node.delegateName),
        newEmptyNode(),
        funcTy
      )
    )

  of xnkBlockStmt:
    result = newNimNode(nnkBlockStmt)
    result.add(newEmptyNode())  # no label
    let stmtList = newStmtList()
    for stmt in node.blockBody:
      stmtList.add(transformToNim(stmt))
    result.add(stmtList)

  of xnkIfStmt:
    result = newNimNode(nnkIfStmt)
    let branch = newNimNode(nnkElifBranch)
    branch.add(transformToNim(node.ifCondition))
    branch.add(transformToNim(node.ifBody))
    result.add(branch)
    if node.elseBody.isSome:
      let elseBranch = newNimNode(nnkElse)
      elseBranch.add(transformToNim(node.elseBody.get))
      result.add(elseBranch)

  of xnkSwitchStmt:
    result = newNimNode(nnkCaseStmt)
    result.add(transformToNim(node.switchExpr))
    for case in node.switchCases:
      let ofBranch = newNimNode(nnkOfBranch)
      ofBranch.add(transformToNim(case.caseExpr))
      ofBranch.add(transformToNim(case.caseBody))
      result.add(ofBranch)
    if node.switchDefault.isSome:
      let elseBranch = newNimNode(nnkElse)
      elseBranch.add(transformToNim(node.switchDefault.get))
      result.add(elseBranch)

  of xnkForStmt:
    if node.forInit.isSome and node.forCond.isSome and node.forIncrement.isSome:
      # C-style for loop
      let init = transformToNim(node.forInit.get)
      let cond = transformToNim(node.forCond.get)
      let incr = transformToNim(node.forIncrement.get)
      let body = transformToNim(node.forBody)
      result = quote do:
        block:
          `init`
          while `cond`:
            `body`
            `incr`
    else:
      # Assume it's a for-in loop
      result = newNimNode(nnkForStmt)
      result.add(transformToNim(node.forInit.get))
      result.add(transformToNim(node.forCond.get))
      result.add(transformToNim(node.forBody))

  of xnkWhileStmt, xnkDoWhileStmt:
    if node.kind == xnkWhileStmt:
      result = newNimNode(nnkWhileStmt)
      result.add(transformToNim(node.whileCondition))
      result.add(transformToNim(node.whileBody))
    else:
      # Do-while doesn't exist in Nim, we'll use a while(true) with a break
      let condition = transformToNim(node.whileCondition)
      let body = transformToNim(node.whileBody)
      result = quote do:
        while true:
          `body`
          if not `condition`:
            break

  of xnkForeachStmt:
    result = newNimNode(nnkForStmt)
    result.add(transformToNim(node.foreachVar))
    result.add(transformToNim(node.foreachIter))
    result.add(transformToNim(node.foreachBody))

  of xnkTryStmt:
    result = newNimNode(nnkTryStmt)
    result.add(transformToNim(node.tryBody))
    for exceptionHandler in node.catchClauses:
      result.add(transformToNim(exceptionHandler))
    if node.finallyClause.isSome:
      let finallyBranch = newNimNode(nnkFinally)
      finallyBranch.add(transformToNim(node.finallyClause.get))
      result.add(finallyBranch)

  of xnkCatchStmt:
    result = newNimNode(nnkExceptBranch)
    if node.catchType.isSome:
      result.add(transformToNim(node.catchType.get))
    else:
      result.add(newEmptyNode())
    if node.catchVar.isSome:
      result.add(newIdentNode(node.catchVar.get))
    result.add(transformToNim(node.catchBody))

  of xnkFinallyStmt:
    result = newNimNode(nnkFinally)
    result.add(transformToNim(node.finallyBody))

  of xnkReturnStmt:
    result = newNimNode(nnkReturnStmt)
    if node.returnExpr.isSome:
      result.add(transformToNim(node.returnExpr.get))
    else:
      result.add(newEmptyNode())

  of xnkYieldStmt:
    result = newNimNode(nnkYieldStmt)
    result.add(transformToNim(node.yieldExpr))

  of xnkBreakStmt, xnkContinueStmt:
    result = newNimNode(if node.kind == xnkBreakStmt: nnkBreakStmt else: nnkContinueStmt)
    if node.label.isSome:
      result.add(newIdentNode(node.label.get))
    else:
      result.add(newEmptyNode())

  of xnkThrowStmt:
    result = newNimNode(nnkRaiseStmt)
    result.add(transformToNim(node.throwExpr))

  of xnkAssertStmt:
    result = newNimNode(nnkAssert)
    result.add(transformToNim(node.assertCond))
    if node.assertMsg.isSome:
      result.add(transformToNim(node.assertMsg.get))

  of xnkWithStmt:
    # Nim doesn't have a direct equivalent to 'with', we'll use a block
    result = newNimNode(nnkBlockStmt)
    result.add(newEmptyNode())  # no label
    let stmtList = newStmtList()
    for item in node.withItems:
      let contextExpr = transformToNim(item.contextExpr)
      if item.asExpr.isSome:
        let asExpr = transformToNim(item.asExpr.get)
        stmtList.add(quote do:
          let `asExpr` = `contextExpr`
        )
      else:
        stmtList.add(contextExpr)
    stmtList.add(transformToNim(node.withBody))
    result.add(stmtList)

  of xnkPassStmt:
    result = newNimNode(nnkDiscardStmt)
    result.add(newEmptyNode())

  of xnkBinaryExpr:
    result = newNimNode(nnkInfix)
    result.add(newIdentNode(node.b