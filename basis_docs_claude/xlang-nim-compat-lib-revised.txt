# compat_lib.nim

import asyncdispatch, locks, tables, sets

# Go-like concurrency
type
  GoRoutine = proc() {.thread.}
  Channel[T] = ref object
    queue: seq[T]
    lock: Lock
    notEmpty, notFull: Cond
    capacity: int

proc go*(routine: GoRoutine) =
  ## Mimics Go's goroutine creation
  var thread: Thread[void]
  createThread(thread, routine)

proc newChannel[T](capacity: int = 0): Channel[T] =
  ## Creates a new channel with optional capacity
  result = Channel[T](capacity: capacity)
  initLock(result.lock)
  initCond(result.notEmpty)
  initCond(result.notFull)

proc send[T](ch: Channel[T], item: T) =
  ## Sends an item to the channel
  acquire(ch.lock)
  while ch.queue.len == ch.capacity and ch.capacity > 0:
    wait(ch.notFull, ch.lock)
  ch.queue.add(item)
  signal(ch.notEmpty)
  release(ch.lock)

proc recv[T](ch: Channel[T]): T =
  ## Receives an item from the channel
  acquire(ch.lock)
  while ch.queue.len == 0:
    wait(ch.notEmpty, ch.lock)
  result = ch.queue.pop()
  signal(ch.notFull)
  release(ch.lock)

# Python-like slicing
proc slice[T](s: openArray[T], start, stop, step: int): seq[T] =
  ## Mimics Python's slicing behavior
  result = @[]
  var i = start
  while (if step > 0: i < stop else: i > stop):
    result.add(s[i])
    i += step

# C#-like properties
template property*(name: untyped, getterBody, setterBody: untyped) =
  proc `name`(): auto = getterBody
  proc `name=`(value: auto) = setterBody

# Error handling (Go-like)
type
  Result[T] = object
    case isOk: bool
    of true:
      value: T
    of false:
      error: ref Exception

proc ok[T](value: T): Result[T] =
  Result[T](isOk: true, value: value)

proc err[T](error: ref Exception): Result[T] =
  Result[T](isOk: false, error: error)

template check*(result: Result, body: untyped) =
  if result.isOk:
    let it {.inject.} = result.value
    body
  else:
    raise result.error

# Exporting the public API
export go, Channel, newChannel, send, recv
export slice
export property
export Result, ok, err, check
